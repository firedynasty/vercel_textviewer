{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n// Split text into sentences\nfunction splitIntoSentences(text) {\n  if (!text) return [];\n  // Split on Chinese/English punctuation and newlines\n  const sentences = text.split(/[。！？.!?\\n]+/).map(s => s.trim()).filter(s => s.length > 0);\n  return sentences;\n}\nexport function useTTS() {\n  _s();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);\n  const [sentences, setSentences] = useState([]);\n  const [speed, setSpeed] = useState(1);\n  const [language, setLanguage] = useState('en-US'); // 'en-US', 'zh-HK', 'zh-CN'\n  const [sentenceCount, setSentenceCount] = useState(5);\n  const [repeatMode, setRepeatMode] = useState('continue'); // 'repeat' or 'continue'\n\n  const utteranceRef = useRef(null);\n  const sentencesReadRef = useRef(0);\n  const startIndexRef = useRef(0);\n\n  // Load text and split into sentences\n  const loadText = useCallback(text => {\n    const newSentences = splitIntoSentences(text);\n    setSentences(newSentences);\n    setCurrentSentenceIndex(0);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = 0;\n  }, []);\n\n  // Stop speech\n  const stop = useCallback(() => {\n    window.speechSynthesis.cancel();\n    setIsPlaying(false);\n    if (utteranceRef.current) {\n      utteranceRef.current.onend = null;\n      utteranceRef.current.onerror = null;\n      utteranceRef.current = null;\n    }\n  }, []);\n\n  // Speak a single sentence\n  const speakSentence = useCallback(index => {\n    if (index >= sentences.length || index < 0) {\n      stop();\n      return;\n    }\n    const sentence = sentences[index];\n    if (!sentence) {\n      stop();\n      return;\n    }\n    const utterance = new SpeechSynthesisUtterance(sentence);\n    utterance.rate = speed;\n    utterance.lang = language;\n\n    // Try to find a matching voice\n    const voices = window.speechSynthesis.getVoices();\n    const matchingVoice = voices.find(v => v.lang === language) || voices.find(v => v.lang.startsWith(language.split('-')[0]));\n    if (matchingVoice) {\n      utterance.voice = matchingVoice;\n    }\n    utterance.onend = () => {\n      sentencesReadRef.current++;\n\n      // Check if we've read enough sentences\n      if (sentencesReadRef.current >= sentenceCount) {\n        stop();\n        return;\n      }\n      if (repeatMode === 'repeat') {\n        // Repeat the same sentence\n        setTimeout(() => {\n          if (utteranceRef.current) {\n            speakSentence(index);\n          }\n        }, 300);\n      } else {\n        // Continue to next sentence\n        const nextIndex = index + 1;\n        if (nextIndex < sentences.length) {\n          setCurrentSentenceIndex(nextIndex);\n          setTimeout(() => {\n            if (utteranceRef.current !== null || isPlaying) {\n              speakSentence(nextIndex);\n            }\n          }, 300);\n        } else {\n          stop();\n        }\n      }\n    };\n    utterance.onerror = event => {\n      console.error('Speech synthesis error:', event);\n      stop();\n    };\n    utteranceRef.current = utterance;\n    setCurrentSentenceIndex(index);\n    window.speechSynthesis.cancel();\n    setTimeout(() => {\n      window.speechSynthesis.speak(utterance);\n    }, 100);\n  }, [sentences, speed, language, sentenceCount, repeatMode, stop, isPlaying]);\n\n  // Play from current position\n  const play = useCallback(() => {\n    if (sentences.length === 0) return;\n    setIsPlaying(true);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = currentSentenceIndex;\n    speakSentence(currentSentenceIndex);\n  }, [sentences.length, currentSentenceIndex, speakSentence]);\n\n  // Navigate to previous sentence\n  const prevSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.max(0, prev - 1));\n  }, [stop]);\n\n  // Navigate to next sentence\n  const nextSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.min(sentences.length - 1, prev + 1));\n  }, [stop, sentences.length]);\n\n  // Find sentence containing selected text and play from there\n  const playFromSelection = useCallback(selectedText => {\n    console.log('playFromSelection called with:', selectedText);\n    console.log('sentences count:', sentences.length);\n    if (!selectedText || sentences.length === 0) {\n      console.log('Early return: no text or no sentences');\n      return false;\n    }\n\n    // Clean up selection - remove extra whitespace, newlines\n    const trimmedSelection = selectedText.trim().replace(/\\s+/g, ' ');\n    console.log('trimmed selection:', trimmedSelection);\n    if (trimmedSelection.length < 2) {\n      console.log('Selection too short');\n      return false;\n    }\n\n    // Try exact substring match first\n    let foundIndex = sentences.findIndex(sentence => {\n      const cleanSentence = sentence.trim();\n      return cleanSentence.includes(trimmedSelection) || trimmedSelection.includes(cleanSentence);\n    });\n    console.log('Exact match index:', foundIndex);\n\n    // Try character-by-character match for Chinese text\n    if (foundIndex === -1) {\n      const selectionChars = trimmedSelection.replace(/\\s/g, '');\n      foundIndex = sentences.findIndex(sentence => {\n        const sentenceChars = sentence.replace(/\\s/g, '');\n        return sentenceChars.includes(selectionChars) || selectionChars.includes(sentenceChars);\n      });\n      console.log('Character match index:', foundIndex);\n    }\n\n    // Try finding first few characters match\n    if (foundIndex === -1 && trimmedSelection.length >= 3) {\n      const firstChars = trimmedSelection.substring(0, Math.min(10, trimmedSelection.length)).replace(/\\s/g, '');\n      foundIndex = sentences.findIndex(sentence => {\n        const sentenceChars = sentence.replace(/\\s/g, '');\n        return sentenceChars.includes(firstChars);\n      });\n      console.log('First chars match index:', foundIndex, 'looking for:', firstChars);\n    }\n    if (foundIndex !== -1) {\n      console.log('Found sentence:', sentences[foundIndex]);\n      stop();\n      setCurrentSentenceIndex(foundIndex);\n      setIsPlaying(true);\n      sentencesReadRef.current = 0;\n      startIndexRef.current = foundIndex;\n      setTimeout(() => {\n        speakSentence(foundIndex);\n      }, 100);\n      return true;\n    }\n\n    // Try partial match - find sentence with most character overlap\n    let bestMatch = -1;\n    let bestScore = 0;\n    const selectionChars = [...trimmedSelection.replace(/\\s/g, '')];\n    sentences.forEach((sentence, idx) => {\n      const sentenceChars = sentence.replace(/\\s/g, '');\n      let matchCount = 0;\n      selectionChars.forEach(char => {\n        if (sentenceChars.includes(char)) matchCount++;\n      });\n      const score = matchCount / selectionChars.length;\n      if (score > bestScore && score > 0.5) {\n        bestScore = score;\n        bestMatch = idx;\n      }\n    });\n    console.log('Best partial match:', bestMatch, 'score:', bestScore);\n    if (bestMatch !== -1) {\n      console.log('Using partial match sentence:', sentences[bestMatch]);\n      stop();\n      setCurrentSentenceIndex(bestMatch);\n      setIsPlaying(true);\n      sentencesReadRef.current = 0;\n      startIndexRef.current = bestMatch;\n      setTimeout(() => {\n        speakSentence(bestMatch);\n      }, 100);\n      return true;\n    }\n    console.log('No match found');\n    return false;\n  }, [sentences, stop, speakSentence]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      window.speechSynthesis.cancel();\n    };\n  }, []);\n\n  // Get current sentence text for display\n  const currentSentenceText = sentences[currentSentenceIndex] || '';\n  const sentenceIndicator = sentences.length > 0 ? `${currentSentenceIndex + 1}/${sentences.length}: ${currentSentenceText.substring(0, 20)}${currentSentenceText.length > 20 ? '...' : ''}` : 'Ready to read...';\n  return {\n    // State\n    isPlaying,\n    currentSentenceIndex,\n    sentences,\n    speed,\n    language,\n    sentenceCount,\n    repeatMode,\n    sentenceIndicator,\n    // Actions\n    loadText,\n    play,\n    stop,\n    prevSentence,\n    nextSentence,\n    playFromSelection,\n    setSpeed,\n    setLanguage,\n    setSentenceCount,\n    setRepeatMode,\n    setCurrentSentenceIndex\n  };\n}\n_s(useTTS, \"Fd5umYPGUUpE+WjLG6fTJ2BrxmY=\");","map":{"version":3,"names":["useState","useCallback","useRef","useEffect","splitIntoSentences","text","sentences","split","map","s","trim","filter","length","useTTS","_s","isPlaying","setIsPlaying","currentSentenceIndex","setCurrentSentenceIndex","setSentences","speed","setSpeed","language","setLanguage","sentenceCount","setSentenceCount","repeatMode","setRepeatMode","utteranceRef","sentencesReadRef","startIndexRef","loadText","newSentences","current","stop","window","speechSynthesis","cancel","onend","onerror","speakSentence","index","sentence","utterance","SpeechSynthesisUtterance","rate","lang","voices","getVoices","matchingVoice","find","v","startsWith","voice","setTimeout","nextIndex","event","console","error","speak","play","prevSentence","prev","Math","max","nextSentence","min","playFromSelection","selectedText","log","trimmedSelection","replace","foundIndex","findIndex","cleanSentence","includes","selectionChars","sentenceChars","firstChars","substring","bestMatch","bestScore","forEach","idx","matchCount","char","score","currentSentenceText","sentenceIndicator"],"sources":["/Users/stanleytan/Documents/25-technical/01-github/vercel_textviewer/src/hooks/useTTS.js"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\n\n// Split text into sentences\nfunction splitIntoSentences(text) {\n  if (!text) return [];\n  // Split on Chinese/English punctuation and newlines\n  const sentences = text\n    .split(/[。！？.!?\\n]+/)\n    .map(s => s.trim())\n    .filter(s => s.length > 0);\n  return sentences;\n}\n\nexport function useTTS() {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);\n  const [sentences, setSentences] = useState([]);\n  const [speed, setSpeed] = useState(1);\n  const [language, setLanguage] = useState('en-US'); // 'en-US', 'zh-HK', 'zh-CN'\n  const [sentenceCount, setSentenceCount] = useState(5);\n  const [repeatMode, setRepeatMode] = useState('continue'); // 'repeat' or 'continue'\n\n  const utteranceRef = useRef(null);\n  const sentencesReadRef = useRef(0);\n  const startIndexRef = useRef(0);\n\n  // Load text and split into sentences\n  const loadText = useCallback((text) => {\n    const newSentences = splitIntoSentences(text);\n    setSentences(newSentences);\n    setCurrentSentenceIndex(0);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = 0;\n  }, []);\n\n  // Stop speech\n  const stop = useCallback(() => {\n    window.speechSynthesis.cancel();\n    setIsPlaying(false);\n    if (utteranceRef.current) {\n      utteranceRef.current.onend = null;\n      utteranceRef.current.onerror = null;\n      utteranceRef.current = null;\n    }\n  }, []);\n\n  // Speak a single sentence\n  const speakSentence = useCallback((index) => {\n    if (index >= sentences.length || index < 0) {\n      stop();\n      return;\n    }\n\n    const sentence = sentences[index];\n    if (!sentence) {\n      stop();\n      return;\n    }\n\n    const utterance = new SpeechSynthesisUtterance(sentence);\n    utterance.rate = speed;\n    utterance.lang = language;\n\n    // Try to find a matching voice\n    const voices = window.speechSynthesis.getVoices();\n    const matchingVoice = voices.find(v => v.lang === language) ||\n                          voices.find(v => v.lang.startsWith(language.split('-')[0]));\n    if (matchingVoice) {\n      utterance.voice = matchingVoice;\n    }\n\n    utterance.onend = () => {\n      sentencesReadRef.current++;\n\n      // Check if we've read enough sentences\n      if (sentencesReadRef.current >= sentenceCount) {\n        stop();\n        return;\n      }\n\n      if (repeatMode === 'repeat') {\n        // Repeat the same sentence\n        setTimeout(() => {\n          if (utteranceRef.current) {\n            speakSentence(index);\n          }\n        }, 300);\n      } else {\n        // Continue to next sentence\n        const nextIndex = index + 1;\n        if (nextIndex < sentences.length) {\n          setCurrentSentenceIndex(nextIndex);\n          setTimeout(() => {\n            if (utteranceRef.current !== null || isPlaying) {\n              speakSentence(nextIndex);\n            }\n          }, 300);\n        } else {\n          stop();\n        }\n      }\n    };\n\n    utterance.onerror = (event) => {\n      console.error('Speech synthesis error:', event);\n      stop();\n    };\n\n    utteranceRef.current = utterance;\n    setCurrentSentenceIndex(index);\n    window.speechSynthesis.cancel();\n\n    setTimeout(() => {\n      window.speechSynthesis.speak(utterance);\n    }, 100);\n  }, [sentences, speed, language, sentenceCount, repeatMode, stop, isPlaying]);\n\n  // Play from current position\n  const play = useCallback(() => {\n    if (sentences.length === 0) return;\n\n    setIsPlaying(true);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = currentSentenceIndex;\n    speakSentence(currentSentenceIndex);\n  }, [sentences.length, currentSentenceIndex, speakSentence]);\n\n  // Navigate to previous sentence\n  const prevSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.max(0, prev - 1));\n  }, [stop]);\n\n  // Navigate to next sentence\n  const nextSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.min(sentences.length - 1, prev + 1));\n  }, [stop, sentences.length]);\n\n  // Find sentence containing selected text and play from there\n  const playFromSelection = useCallback((selectedText) => {\n    console.log('playFromSelection called with:', selectedText);\n    console.log('sentences count:', sentences.length);\n\n    if (!selectedText || sentences.length === 0) {\n      console.log('Early return: no text or no sentences');\n      return false;\n    }\n\n    // Clean up selection - remove extra whitespace, newlines\n    const trimmedSelection = selectedText.trim().replace(/\\s+/g, ' ');\n    console.log('trimmed selection:', trimmedSelection);\n\n    if (trimmedSelection.length < 2) {\n      console.log('Selection too short');\n      return false;\n    }\n\n    // Try exact substring match first\n    let foundIndex = sentences.findIndex(sentence => {\n      const cleanSentence = sentence.trim();\n      return cleanSentence.includes(trimmedSelection) || trimmedSelection.includes(cleanSentence);\n    });\n\n    console.log('Exact match index:', foundIndex);\n\n    // Try character-by-character match for Chinese text\n    if (foundIndex === -1) {\n      const selectionChars = trimmedSelection.replace(/\\s/g, '');\n      foundIndex = sentences.findIndex(sentence => {\n        const sentenceChars = sentence.replace(/\\s/g, '');\n        return sentenceChars.includes(selectionChars) || selectionChars.includes(sentenceChars);\n      });\n      console.log('Character match index:', foundIndex);\n    }\n\n    // Try finding first few characters match\n    if (foundIndex === -1 && trimmedSelection.length >= 3) {\n      const firstChars = trimmedSelection.substring(0, Math.min(10, trimmedSelection.length)).replace(/\\s/g, '');\n      foundIndex = sentences.findIndex(sentence => {\n        const sentenceChars = sentence.replace(/\\s/g, '');\n        return sentenceChars.includes(firstChars);\n      });\n      console.log('First chars match index:', foundIndex, 'looking for:', firstChars);\n    }\n\n    if (foundIndex !== -1) {\n      console.log('Found sentence:', sentences[foundIndex]);\n      stop();\n      setCurrentSentenceIndex(foundIndex);\n      setIsPlaying(true);\n      sentencesReadRef.current = 0;\n      startIndexRef.current = foundIndex;\n      setTimeout(() => {\n        speakSentence(foundIndex);\n      }, 100);\n      return true;\n    }\n\n    // Try partial match - find sentence with most character overlap\n    let bestMatch = -1;\n    let bestScore = 0;\n    const selectionChars = [...trimmedSelection.replace(/\\s/g, '')];\n\n    sentences.forEach((sentence, idx) => {\n      const sentenceChars = sentence.replace(/\\s/g, '');\n      let matchCount = 0;\n      selectionChars.forEach(char => {\n        if (sentenceChars.includes(char)) matchCount++;\n      });\n      const score = matchCount / selectionChars.length;\n      if (score > bestScore && score > 0.5) {\n        bestScore = score;\n        bestMatch = idx;\n      }\n    });\n\n    console.log('Best partial match:', bestMatch, 'score:', bestScore);\n\n    if (bestMatch !== -1) {\n      console.log('Using partial match sentence:', sentences[bestMatch]);\n      stop();\n      setCurrentSentenceIndex(bestMatch);\n      setIsPlaying(true);\n      sentencesReadRef.current = 0;\n      startIndexRef.current = bestMatch;\n      setTimeout(() => {\n        speakSentence(bestMatch);\n      }, 100);\n      return true;\n    }\n\n    console.log('No match found');\n    return false;\n  }, [sentences, stop, speakSentence]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      window.speechSynthesis.cancel();\n    };\n  }, []);\n\n  // Get current sentence text for display\n  const currentSentenceText = sentences[currentSentenceIndex] || '';\n  const sentenceIndicator = sentences.length > 0\n    ? `${currentSentenceIndex + 1}/${sentences.length}: ${currentSentenceText.substring(0, 20)}${currentSentenceText.length > 20 ? '...' : ''}`\n    : 'Ready to read...';\n\n  return {\n    // State\n    isPlaying,\n    currentSentenceIndex,\n    sentences,\n    speed,\n    language,\n    sentenceCount,\n    repeatMode,\n    sentenceIndicator,\n\n    // Actions\n    loadText,\n    play,\n    stop,\n    prevSentence,\n    nextSentence,\n    playFromSelection,\n    setSpeed,\n    setLanguage,\n    setSentenceCount,\n    setRepeatMode,\n    setCurrentSentenceIndex,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}