{"ast":null,"code":"import{useState,useCallback,useRef,useEffect}from'react';// Split text into sentences\nfunction splitIntoSentences(text){if(!text)return[];// Split on Chinese/English punctuation and newlines\nconst sentences=text.split(/[。！？.!?\\n]+/).map(s=>s.trim()).filter(s=>s.length>0);return sentences;}export function useTTS(){const[isPlaying,setIsPlaying]=useState(false);const[currentSentenceIndex,setCurrentSentenceIndex]=useState(0);const[sentences,setSentences]=useState([]);const[speed,setSpeed]=useState(1);const[language,setLanguage]=useState('en-US');// 'en-US', 'zh-HK', 'zh-CN'\nconst[sentenceCount,setSentenceCount]=useState(5);const[repeatMode,setRepeatMode]=useState('continue');// 'repeat' or 'continue'\nconst utteranceRef=useRef(null);const sentencesReadRef=useRef(0);const startIndexRef=useRef(0);// Load text and split into sentences\nconst loadText=useCallback(text=>{const newSentences=splitIntoSentences(text);setSentences(newSentences);setCurrentSentenceIndex(0);sentencesReadRef.current=0;startIndexRef.current=0;},[]);// Stop speech\nconst stop=useCallback(()=>{window.speechSynthesis.cancel();setIsPlaying(false);if(utteranceRef.current){utteranceRef.current.onend=null;utteranceRef.current.onerror=null;utteranceRef.current=null;}},[]);// Speak a single sentence\nconst speakSentence=useCallback(index=>{if(index>=sentences.length||index<0){stop();return;}const sentence=sentences[index];if(!sentence){stop();return;}const utterance=new SpeechSynthesisUtterance(sentence);utterance.rate=speed;utterance.lang=language;// Try to find a matching voice\nconst voices=window.speechSynthesis.getVoices();const matchingVoice=voices.find(v=>v.lang===language)||voices.find(v=>v.lang.startsWith(language.split('-')[0]));if(matchingVoice){utterance.voice=matchingVoice;}utterance.onend=()=>{sentencesReadRef.current++;// Check if we've read enough sentences\nif(sentencesReadRef.current>=sentenceCount){stop();return;}if(repeatMode==='repeat'){// Repeat the same sentence\nsetTimeout(()=>{if(utteranceRef.current){speakSentence(index);}},300);}else{// Continue to next sentence\nconst nextIndex=index+1;if(nextIndex<sentences.length){setCurrentSentenceIndex(nextIndex);setTimeout(()=>{if(utteranceRef.current!==null||isPlaying){speakSentence(nextIndex);}},300);}else{stop();}}};utterance.onerror=event=>{console.error('Speech synthesis error:',event);stop();};utteranceRef.current=utterance;setCurrentSentenceIndex(index);window.speechSynthesis.cancel();setTimeout(()=>{window.speechSynthesis.speak(utterance);},100);},[sentences,speed,language,sentenceCount,repeatMode,stop,isPlaying]);// Play from current position\nconst play=useCallback(()=>{if(sentences.length===0)return;setIsPlaying(true);sentencesReadRef.current=0;startIndexRef.current=currentSentenceIndex;speakSentence(currentSentenceIndex);},[sentences.length,currentSentenceIndex,speakSentence]);// Navigate to previous sentence\nconst prevSentence=useCallback(()=>{stop();setCurrentSentenceIndex(prev=>Math.max(0,prev-1));},[stop]);// Navigate to next sentence\nconst nextSentence=useCallback(()=>{stop();setCurrentSentenceIndex(prev=>Math.min(sentences.length-1,prev+1));},[stop,sentences.length]);// Find sentence containing selected text and play from there\nconst playFromSelection=useCallback(selectedText=>{console.log('playFromSelection called with:',selectedText);console.log('sentences count:',sentences.length);if(!selectedText||sentences.length===0){console.log('Early return: no text or no sentences');return false;}// Clean up selection - remove extra whitespace, newlines\nconst trimmedSelection=selectedText.trim().replace(/\\s+/g,' ');console.log('trimmed selection:',trimmedSelection);if(trimmedSelection.length<2){console.log('Selection too short');return false;}// Try exact substring match first\nlet foundIndex=sentences.findIndex(sentence=>{const cleanSentence=sentence.trim();return cleanSentence.includes(trimmedSelection)||trimmedSelection.includes(cleanSentence);});console.log('Exact match index:',foundIndex);// Try character-by-character match for Chinese text\nif(foundIndex===-1){const selectionChars=trimmedSelection.replace(/\\s/g,'');foundIndex=sentences.findIndex(sentence=>{const sentenceChars=sentence.replace(/\\s/g,'');return sentenceChars.includes(selectionChars)||selectionChars.includes(sentenceChars);});console.log('Character match index:',foundIndex);}// Try finding first few characters match\nif(foundIndex===-1&&trimmedSelection.length>=3){const firstChars=trimmedSelection.substring(0,Math.min(10,trimmedSelection.length)).replace(/\\s/g,'');foundIndex=sentences.findIndex(sentence=>{const sentenceChars=sentence.replace(/\\s/g,'');return sentenceChars.includes(firstChars);});console.log('First chars match index:',foundIndex,'looking for:',firstChars);}if(foundIndex!==-1){console.log('Found sentence:',sentences[foundIndex]);stop();setCurrentSentenceIndex(foundIndex);setIsPlaying(true);sentencesReadRef.current=0;startIndexRef.current=foundIndex;setTimeout(()=>{speakSentence(foundIndex);},100);return true;}// Try partial match - find sentence with most character overlap\nlet bestMatch=-1;let bestScore=0;const selectionChars=[...trimmedSelection.replace(/\\s/g,'')];sentences.forEach((sentence,idx)=>{const sentenceChars=sentence.replace(/\\s/g,'');let matchCount=0;selectionChars.forEach(char=>{if(sentenceChars.includes(char))matchCount++;});const score=matchCount/selectionChars.length;if(score>bestScore&&score>0.5){bestScore=score;bestMatch=idx;}});console.log('Best partial match:',bestMatch,'score:',bestScore);if(bestMatch!==-1){console.log('Using partial match sentence:',sentences[bestMatch]);stop();setCurrentSentenceIndex(bestMatch);setIsPlaying(true);sentencesReadRef.current=0;startIndexRef.current=bestMatch;setTimeout(()=>{speakSentence(bestMatch);},100);return true;}console.log('No match found');return false;},[sentences,stop,speakSentence]);// Cleanup on unmount\nuseEffect(()=>{return()=>{window.speechSynthesis.cancel();};},[]);// Get current sentence text for display\nconst currentSentenceText=sentences[currentSentenceIndex]||'';const sentenceIndicator=sentences.length>0?\"\".concat(currentSentenceIndex+1,\"/\").concat(sentences.length,\": \").concat(currentSentenceText.substring(0,20)).concat(currentSentenceText.length>20?'...':''):'Ready to read...';return{// State\nisPlaying,currentSentenceIndex,sentences,speed,language,sentenceCount,repeatMode,sentenceIndicator,// Actions\nloadText,play,stop,prevSentence,nextSentence,playFromSelection,setSpeed,setLanguage,setSentenceCount,setRepeatMode,setCurrentSentenceIndex};}","map":{"version":3,"names":["useState","useCallback","useRef","useEffect","splitIntoSentences","text","sentences","split","map","s","trim","filter","length","useTTS","isPlaying","setIsPlaying","currentSentenceIndex","setCurrentSentenceIndex","setSentences","speed","setSpeed","language","setLanguage","sentenceCount","setSentenceCount","repeatMode","setRepeatMode","utteranceRef","sentencesReadRef","startIndexRef","loadText","newSentences","current","stop","window","speechSynthesis","cancel","onend","onerror","speakSentence","index","sentence","utterance","SpeechSynthesisUtterance","rate","lang","voices","getVoices","matchingVoice","find","v","startsWith","voice","setTimeout","nextIndex","event","console","error","speak","play","prevSentence","prev","Math","max","nextSentence","min","playFromSelection","selectedText","log","trimmedSelection","replace","foundIndex","findIndex","cleanSentence","includes","selectionChars","sentenceChars","firstChars","substring","bestMatch","bestScore","forEach","idx","matchCount","char","score","currentSentenceText","sentenceIndicator","concat"],"sources":["/Users/stanleytan/Documents/25-technical/01-github/vercel_textviewer/src/hooks/useTTS.js"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\n\n// Split text into sentences\nfunction splitIntoSentences(text) {\n  if (!text) return [];\n  // Split on Chinese/English punctuation and newlines\n  const sentences = text\n    .split(/[。！？.!?\\n]+/)\n    .map(s => s.trim())\n    .filter(s => s.length > 0);\n  return sentences;\n}\n\nexport function useTTS() {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);\n  const [sentences, setSentences] = useState([]);\n  const [speed, setSpeed] = useState(1);\n  const [language, setLanguage] = useState('en-US'); // 'en-US', 'zh-HK', 'zh-CN'\n  const [sentenceCount, setSentenceCount] = useState(5);\n  const [repeatMode, setRepeatMode] = useState('continue'); // 'repeat' or 'continue'\n\n  const utteranceRef = useRef(null);\n  const sentencesReadRef = useRef(0);\n  const startIndexRef = useRef(0);\n\n  // Load text and split into sentences\n  const loadText = useCallback((text) => {\n    const newSentences = splitIntoSentences(text);\n    setSentences(newSentences);\n    setCurrentSentenceIndex(0);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = 0;\n  }, []);\n\n  // Stop speech\n  const stop = useCallback(() => {\n    window.speechSynthesis.cancel();\n    setIsPlaying(false);\n    if (utteranceRef.current) {\n      utteranceRef.current.onend = null;\n      utteranceRef.current.onerror = null;\n      utteranceRef.current = null;\n    }\n  }, []);\n\n  // Speak a single sentence\n  const speakSentence = useCallback((index) => {\n    if (index >= sentences.length || index < 0) {\n      stop();\n      return;\n    }\n\n    const sentence = sentences[index];\n    if (!sentence) {\n      stop();\n      return;\n    }\n\n    const utterance = new SpeechSynthesisUtterance(sentence);\n    utterance.rate = speed;\n    utterance.lang = language;\n\n    // Try to find a matching voice\n    const voices = window.speechSynthesis.getVoices();\n    const matchingVoice = voices.find(v => v.lang === language) ||\n                          voices.find(v => v.lang.startsWith(language.split('-')[0]));\n    if (matchingVoice) {\n      utterance.voice = matchingVoice;\n    }\n\n    utterance.onend = () => {\n      sentencesReadRef.current++;\n\n      // Check if we've read enough sentences\n      if (sentencesReadRef.current >= sentenceCount) {\n        stop();\n        return;\n      }\n\n      if (repeatMode === 'repeat') {\n        // Repeat the same sentence\n        setTimeout(() => {\n          if (utteranceRef.current) {\n            speakSentence(index);\n          }\n        }, 300);\n      } else {\n        // Continue to next sentence\n        const nextIndex = index + 1;\n        if (nextIndex < sentences.length) {\n          setCurrentSentenceIndex(nextIndex);\n          setTimeout(() => {\n            if (utteranceRef.current !== null || isPlaying) {\n              speakSentence(nextIndex);\n            }\n          }, 300);\n        } else {\n          stop();\n        }\n      }\n    };\n\n    utterance.onerror = (event) => {\n      console.error('Speech synthesis error:', event);\n      stop();\n    };\n\n    utteranceRef.current = utterance;\n    setCurrentSentenceIndex(index);\n    window.speechSynthesis.cancel();\n\n    setTimeout(() => {\n      window.speechSynthesis.speak(utterance);\n    }, 100);\n  }, [sentences, speed, language, sentenceCount, repeatMode, stop, isPlaying]);\n\n  // Play from current position\n  const play = useCallback(() => {\n    if (sentences.length === 0) return;\n\n    setIsPlaying(true);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = currentSentenceIndex;\n    speakSentence(currentSentenceIndex);\n  }, [sentences.length, currentSentenceIndex, speakSentence]);\n\n  // Navigate to previous sentence\n  const prevSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.max(0, prev - 1));\n  }, [stop]);\n\n  // Navigate to next sentence\n  const nextSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.min(sentences.length - 1, prev + 1));\n  }, [stop, sentences.length]);\n\n  // Find sentence containing selected text and play from there\n  const playFromSelection = useCallback((selectedText) => {\n    console.log('playFromSelection called with:', selectedText);\n    console.log('sentences count:', sentences.length);\n\n    if (!selectedText || sentences.length === 0) {\n      console.log('Early return: no text or no sentences');\n      return false;\n    }\n\n    // Clean up selection - remove extra whitespace, newlines\n    const trimmedSelection = selectedText.trim().replace(/\\s+/g, ' ');\n    console.log('trimmed selection:', trimmedSelection);\n\n    if (trimmedSelection.length < 2) {\n      console.log('Selection too short');\n      return false;\n    }\n\n    // Try exact substring match first\n    let foundIndex = sentences.findIndex(sentence => {\n      const cleanSentence = sentence.trim();\n      return cleanSentence.includes(trimmedSelection) || trimmedSelection.includes(cleanSentence);\n    });\n\n    console.log('Exact match index:', foundIndex);\n\n    // Try character-by-character match for Chinese text\n    if (foundIndex === -1) {\n      const selectionChars = trimmedSelection.replace(/\\s/g, '');\n      foundIndex = sentences.findIndex(sentence => {\n        const sentenceChars = sentence.replace(/\\s/g, '');\n        return sentenceChars.includes(selectionChars) || selectionChars.includes(sentenceChars);\n      });\n      console.log('Character match index:', foundIndex);\n    }\n\n    // Try finding first few characters match\n    if (foundIndex === -1 && trimmedSelection.length >= 3) {\n      const firstChars = trimmedSelection.substring(0, Math.min(10, trimmedSelection.length)).replace(/\\s/g, '');\n      foundIndex = sentences.findIndex(sentence => {\n        const sentenceChars = sentence.replace(/\\s/g, '');\n        return sentenceChars.includes(firstChars);\n      });\n      console.log('First chars match index:', foundIndex, 'looking for:', firstChars);\n    }\n\n    if (foundIndex !== -1) {\n      console.log('Found sentence:', sentences[foundIndex]);\n      stop();\n      setCurrentSentenceIndex(foundIndex);\n      setIsPlaying(true);\n      sentencesReadRef.current = 0;\n      startIndexRef.current = foundIndex;\n      setTimeout(() => {\n        speakSentence(foundIndex);\n      }, 100);\n      return true;\n    }\n\n    // Try partial match - find sentence with most character overlap\n    let bestMatch = -1;\n    let bestScore = 0;\n    const selectionChars = [...trimmedSelection.replace(/\\s/g, '')];\n\n    sentences.forEach((sentence, idx) => {\n      const sentenceChars = sentence.replace(/\\s/g, '');\n      let matchCount = 0;\n      selectionChars.forEach(char => {\n        if (sentenceChars.includes(char)) matchCount++;\n      });\n      const score = matchCount / selectionChars.length;\n      if (score > bestScore && score > 0.5) {\n        bestScore = score;\n        bestMatch = idx;\n      }\n    });\n\n    console.log('Best partial match:', bestMatch, 'score:', bestScore);\n\n    if (bestMatch !== -1) {\n      console.log('Using partial match sentence:', sentences[bestMatch]);\n      stop();\n      setCurrentSentenceIndex(bestMatch);\n      setIsPlaying(true);\n      sentencesReadRef.current = 0;\n      startIndexRef.current = bestMatch;\n      setTimeout(() => {\n        speakSentence(bestMatch);\n      }, 100);\n      return true;\n    }\n\n    console.log('No match found');\n    return false;\n  }, [sentences, stop, speakSentence]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      window.speechSynthesis.cancel();\n    };\n  }, []);\n\n  // Get current sentence text for display\n  const currentSentenceText = sentences[currentSentenceIndex] || '';\n  const sentenceIndicator = sentences.length > 0\n    ? `${currentSentenceIndex + 1}/${sentences.length}: ${currentSentenceText.substring(0, 20)}${currentSentenceText.length > 20 ? '...' : ''}`\n    : 'Ready to read...';\n\n  return {\n    // State\n    isPlaying,\n    currentSentenceIndex,\n    sentences,\n    speed,\n    language,\n    sentenceCount,\n    repeatMode,\n    sentenceIndicator,\n\n    // Actions\n    loadText,\n    play,\n    stop,\n    prevSentence,\n    nextSentence,\n    playFromSelection,\n    setSpeed,\n    setLanguage,\n    setSentenceCount,\n    setRepeatMode,\n    setCurrentSentenceIndex,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}