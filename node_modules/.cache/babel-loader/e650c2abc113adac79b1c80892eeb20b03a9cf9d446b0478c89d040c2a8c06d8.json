{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n// Split text into sentences\nfunction splitIntoSentences(text) {\n  if (!text) return [];\n  // Split on Chinese/English punctuation and newlines\n  const sentences = text.split(/[。！？.!?\\n]+/).map(s => s.trim()).filter(s => s.length > 0);\n  return sentences;\n}\nexport function useTTS() {\n  _s();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);\n  const [sentences, setSentences] = useState([]);\n  const [speed, setSpeed] = useState(1);\n  const [language, setLanguage] = useState('en-US'); // 'en-US', 'zh-HK', 'zh-CN'\n  const [sentenceCount, setSentenceCount] = useState(5);\n  const [repeatMode, setRepeatMode] = useState('continue'); // 'repeat' or 'continue'\n\n  const utteranceRef = useRef(null);\n  const sentencesReadRef = useRef(0);\n  const startIndexRef = useRef(0);\n\n  // Load text and split into sentences\n  const loadText = useCallback(text => {\n    const newSentences = splitIntoSentences(text);\n    setSentences(newSentences);\n    setCurrentSentenceIndex(0);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = 0;\n  }, []);\n\n  // Stop speech\n  const stop = useCallback(() => {\n    window.speechSynthesis.cancel();\n    setIsPlaying(false);\n    if (utteranceRef.current) {\n      utteranceRef.current.onend = null;\n      utteranceRef.current.onerror = null;\n      utteranceRef.current = null;\n    }\n  }, []);\n\n  // Speak a single sentence\n  const speakSentence = useCallback(index => {\n    if (index >= sentences.length || index < 0) {\n      stop();\n      return;\n    }\n    const sentence = sentences[index];\n    if (!sentence) {\n      stop();\n      return;\n    }\n    const utterance = new SpeechSynthesisUtterance(sentence);\n    utterance.rate = speed;\n    utterance.lang = language;\n\n    // Try to find a matching voice\n    const voices = window.speechSynthesis.getVoices();\n    const matchingVoice = voices.find(v => v.lang === language) || voices.find(v => v.lang.startsWith(language.split('-')[0]));\n    if (matchingVoice) {\n      utterance.voice = matchingVoice;\n    }\n    utterance.onend = () => {\n      sentencesReadRef.current++;\n\n      // Check if we've read enough sentences\n      if (sentencesReadRef.current >= sentenceCount) {\n        stop();\n        return;\n      }\n      if (repeatMode === 'repeat') {\n        // Repeat the same sentence\n        setTimeout(() => {\n          if (utteranceRef.current) {\n            speakSentence(index);\n          }\n        }, 300);\n      } else {\n        // Continue to next sentence\n        const nextIndex = index + 1;\n        if (nextIndex < sentences.length) {\n          setCurrentSentenceIndex(nextIndex);\n          setTimeout(() => {\n            if (utteranceRef.current !== null || isPlaying) {\n              speakSentence(nextIndex);\n            }\n          }, 300);\n        } else {\n          stop();\n        }\n      }\n    };\n    utterance.onerror = event => {\n      console.error('Speech synthesis error:', event);\n      stop();\n    };\n    utteranceRef.current = utterance;\n    setCurrentSentenceIndex(index);\n    window.speechSynthesis.cancel();\n    setTimeout(() => {\n      window.speechSynthesis.speak(utterance);\n    }, 100);\n  }, [sentences, speed, language, sentenceCount, repeatMode, stop, isPlaying]);\n\n  // Play from current position\n  const play = useCallback(() => {\n    if (sentences.length === 0) return;\n    setIsPlaying(true);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = currentSentenceIndex;\n    speakSentence(currentSentenceIndex);\n  }, [sentences.length, currentSentenceIndex, speakSentence]);\n\n  // Navigate to previous sentence\n  const prevSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.max(0, prev - 1));\n  }, [stop]);\n\n  // Navigate to next sentence\n  const nextSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.min(sentences.length - 1, prev + 1));\n  }, [stop, sentences.length]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      window.speechSynthesis.cancel();\n    };\n  }, []);\n\n  // Get current sentence text for display\n  const currentSentenceText = sentences[currentSentenceIndex] || '';\n  const sentenceIndicator = sentences.length > 0 ? `${currentSentenceIndex + 1}/${sentences.length}: ${currentSentenceText.substring(0, 20)}${currentSentenceText.length > 20 ? '...' : ''}` : 'Ready to read...';\n  return {\n    // State\n    isPlaying,\n    currentSentenceIndex,\n    sentences,\n    speed,\n    language,\n    sentenceCount,\n    repeatMode,\n    sentenceIndicator,\n    // Actions\n    loadText,\n    play,\n    stop,\n    prevSentence,\n    nextSentence,\n    setSpeed,\n    setLanguage,\n    setSentenceCount,\n    setRepeatMode,\n    setCurrentSentenceIndex\n  };\n}\n_s(useTTS, \"FRTOiW1HB9ftybsqMcAOC9AYKZI=\");","map":{"version":3,"names":["useState","useCallback","useRef","useEffect","splitIntoSentences","text","sentences","split","map","s","trim","filter","length","useTTS","_s","isPlaying","setIsPlaying","currentSentenceIndex","setCurrentSentenceIndex","setSentences","speed","setSpeed","language","setLanguage","sentenceCount","setSentenceCount","repeatMode","setRepeatMode","utteranceRef","sentencesReadRef","startIndexRef","loadText","newSentences","current","stop","window","speechSynthesis","cancel","onend","onerror","speakSentence","index","sentence","utterance","SpeechSynthesisUtterance","rate","lang","voices","getVoices","matchingVoice","find","v","startsWith","voice","setTimeout","nextIndex","event","console","error","speak","play","prevSentence","prev","Math","max","nextSentence","min","currentSentenceText","sentenceIndicator","substring"],"sources":["/Users/stanleytan/Documents/25-technical/01-github/vercel_textviewer/src/hooks/useTTS.js"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\n\n// Split text into sentences\nfunction splitIntoSentences(text) {\n  if (!text) return [];\n  // Split on Chinese/English punctuation and newlines\n  const sentences = text\n    .split(/[。！？.!?\\n]+/)\n    .map(s => s.trim())\n    .filter(s => s.length > 0);\n  return sentences;\n}\n\nexport function useTTS() {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0);\n  const [sentences, setSentences] = useState([]);\n  const [speed, setSpeed] = useState(1);\n  const [language, setLanguage] = useState('en-US'); // 'en-US', 'zh-HK', 'zh-CN'\n  const [sentenceCount, setSentenceCount] = useState(5);\n  const [repeatMode, setRepeatMode] = useState('continue'); // 'repeat' or 'continue'\n\n  const utteranceRef = useRef(null);\n  const sentencesReadRef = useRef(0);\n  const startIndexRef = useRef(0);\n\n  // Load text and split into sentences\n  const loadText = useCallback((text) => {\n    const newSentences = splitIntoSentences(text);\n    setSentences(newSentences);\n    setCurrentSentenceIndex(0);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = 0;\n  }, []);\n\n  // Stop speech\n  const stop = useCallback(() => {\n    window.speechSynthesis.cancel();\n    setIsPlaying(false);\n    if (utteranceRef.current) {\n      utteranceRef.current.onend = null;\n      utteranceRef.current.onerror = null;\n      utteranceRef.current = null;\n    }\n  }, []);\n\n  // Speak a single sentence\n  const speakSentence = useCallback((index) => {\n    if (index >= sentences.length || index < 0) {\n      stop();\n      return;\n    }\n\n    const sentence = sentences[index];\n    if (!sentence) {\n      stop();\n      return;\n    }\n\n    const utterance = new SpeechSynthesisUtterance(sentence);\n    utterance.rate = speed;\n    utterance.lang = language;\n\n    // Try to find a matching voice\n    const voices = window.speechSynthesis.getVoices();\n    const matchingVoice = voices.find(v => v.lang === language) ||\n                          voices.find(v => v.lang.startsWith(language.split('-')[0]));\n    if (matchingVoice) {\n      utterance.voice = matchingVoice;\n    }\n\n    utterance.onend = () => {\n      sentencesReadRef.current++;\n\n      // Check if we've read enough sentences\n      if (sentencesReadRef.current >= sentenceCount) {\n        stop();\n        return;\n      }\n\n      if (repeatMode === 'repeat') {\n        // Repeat the same sentence\n        setTimeout(() => {\n          if (utteranceRef.current) {\n            speakSentence(index);\n          }\n        }, 300);\n      } else {\n        // Continue to next sentence\n        const nextIndex = index + 1;\n        if (nextIndex < sentences.length) {\n          setCurrentSentenceIndex(nextIndex);\n          setTimeout(() => {\n            if (utteranceRef.current !== null || isPlaying) {\n              speakSentence(nextIndex);\n            }\n          }, 300);\n        } else {\n          stop();\n        }\n      }\n    };\n\n    utterance.onerror = (event) => {\n      console.error('Speech synthesis error:', event);\n      stop();\n    };\n\n    utteranceRef.current = utterance;\n    setCurrentSentenceIndex(index);\n    window.speechSynthesis.cancel();\n\n    setTimeout(() => {\n      window.speechSynthesis.speak(utterance);\n    }, 100);\n  }, [sentences, speed, language, sentenceCount, repeatMode, stop, isPlaying]);\n\n  // Play from current position\n  const play = useCallback(() => {\n    if (sentences.length === 0) return;\n\n    setIsPlaying(true);\n    sentencesReadRef.current = 0;\n    startIndexRef.current = currentSentenceIndex;\n    speakSentence(currentSentenceIndex);\n  }, [sentences.length, currentSentenceIndex, speakSentence]);\n\n  // Navigate to previous sentence\n  const prevSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.max(0, prev - 1));\n  }, [stop]);\n\n  // Navigate to next sentence\n  const nextSentence = useCallback(() => {\n    stop();\n    setCurrentSentenceIndex(prev => Math.min(sentences.length - 1, prev + 1));\n  }, [stop, sentences.length]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      window.speechSynthesis.cancel();\n    };\n  }, []);\n\n  // Get current sentence text for display\n  const currentSentenceText = sentences[currentSentenceIndex] || '';\n  const sentenceIndicator = sentences.length > 0\n    ? `${currentSentenceIndex + 1}/${sentences.length}: ${currentSentenceText.substring(0, 20)}${currentSentenceText.length > 20 ? '...' : ''}`\n    : 'Ready to read...';\n\n  return {\n    // State\n    isPlaying,\n    currentSentenceIndex,\n    sentences,\n    speed,\n    language,\n    sentenceCount,\n    repeatMode,\n    sentenceIndicator,\n\n    // Actions\n    loadText,\n    play,\n    stop,\n    prevSentence,\n    nextSentence,\n    setSpeed,\n    setLanguage,\n    setSentenceCount,\n    setRepeatMode,\n    setCurrentSentenceIndex,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}