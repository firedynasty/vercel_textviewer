{"ast":null,"code":"// File type detection utilities\n\nconst VIDEO_EXTENSIONS = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.mkv', '.m4v'];\nconst IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg'];\nconst TEXT_EXTENSIONS = ['.txt', '.rtf'];\nconst MARKDOWN_EXTENSIONS = ['.md'];\nexport function isVideoFile(filename) {\n  const lower = filename.toLowerCase();\n  return VIDEO_EXTENSIONS.some(ext => lower.endsWith(ext));\n}\nexport function isImageFile(filename) {\n  const lower = filename.toLowerCase();\n  return IMAGE_EXTENSIONS.some(ext => lower.endsWith(ext));\n}\nexport function isTextFile(filename) {\n  const lower = filename.toLowerCase();\n  return TEXT_EXTENSIONS.some(ext => lower.endsWith(ext));\n}\nexport function isMarkdownFile(filename) {\n  const lower = filename.toLowerCase();\n  return MARKDOWN_EXTENSIONS.some(ext => lower.endsWith(ext));\n}\nexport function isRtfFile(filename) {\n  return filename.toLowerCase().endsWith('.rtf');\n}\nexport function isValidFile(filename) {\n  return isVideoFile(filename) || isImageFile(filename) || isTextFile(filename) || isMarkdownFile(filename);\n}\nexport function getFileType(filename) {\n  if (isMarkdownFile(filename)) return 'markdown';\n  if (isTextFile(filename)) return 'text';\n  if (isVideoFile(filename)) return 'video';\n  if (isImageFile(filename)) return 'image';\n  return 'unknown';\n}\nexport function getFileExtension(filename) {\n  const match = filename.match(/\\.[^.]+$/);\n  return match ? match[0].toLowerCase() : '';\n}\nexport function getDisplayName(filename) {\n  // Remove extension and return clean display name\n  return filename.replace(/\\.[^.]+$/, '');\n}\n\n// RTF to plain text converter (fallback for when rtf-parser fails)\nexport function rtfToPlainText(rtf) {\n  // Check if this is actually RTF content\n  if (!rtf.trim().startsWith('{\\\\rtf')) {\n    return rtf; // Not RTF, return as-is\n  }\n\n  // Remove nested groups (like fonttbl, colortbl, etc.) by counting braces\n  function removeNestedGroups(text, groupName) {\n    const pattern = new RegExp('\\\\{\\\\\\\\' + groupName, 'gi');\n    let result = '';\n    let i = 0;\n    while (i < text.length) {\n      const match = text.slice(i).match(pattern);\n      if (match && text.slice(i).indexOf(match[0]) === 0) {\n        // Found a group to remove, skip until balanced braces\n        let depth = 1;\n        i += match[0].length;\n        while (i < text.length && depth > 0) {\n          if (text[i] === '{') depth++;else if (text[i] === '}') depth--;\n          i++;\n        }\n      } else {\n        result += text[i];\n        i++;\n      }\n    }\n    return result;\n  }\n  let text = rtf;\n\n  // Remove various RTF groups that don't contain readable text\n  const groupsToRemove = ['fonttbl', 'colortbl', 'stylesheet', 'listtable', 'listoverridetable', 'info', 'expandedcolortbl', '\\\\*\\\\expandedcolortbl', '\\\\*\\\\listtable', '\\\\*\\\\listoverridetable', 'listtext'];\n  for (const group of groupsToRemove) {\n    text = removeNestedGroups(text, group.replace(/\\\\/g, '\\\\\\\\'));\n  }\n\n  // Remove {\\*\\...} destination groups\n  text = text.replace(/\\{\\\\\\*\\\\[^{}]*\\}/g, '');\n\n  // Handle hex characters (\\'XX)\n  text = text.replace(/\\\\'([0-9a-fA-F]{2})/g, (match, hex) => {\n    const code = parseInt(hex, 16);\n    // Map Windows-1252 special chars to Unicode\n    const win1252Map = {\n      0x92: \"'\",\n      0x93: '\"',\n      0x94: '\"',\n      0x96: '–',\n      0x97: '—',\n      0x85: '…',\n      0x91: \"'\",\n      0xa0: ' '\n    };\n    return win1252Map[code] || String.fromCharCode(code);\n  });\n\n  // Handle Unicode characters (\\uN followed by replacement char)\n  text = text.replace(/\\\\u(-?\\d+)[\\s\\\\]?/g, (match, code) => {\n    const charCode = parseInt(code);\n    if (charCode < 0) return String.fromCharCode(charCode + 65536);\n    return String.fromCharCode(charCode);\n  });\n\n  // Replace RTF control words with their meaning\n  text = text.replace(/\\\\par\\b/g, '\\n');\n  text = text.replace(/\\\\line\\b/g, '\\n');\n  text = text.replace(/\\\\tab\\b/g, '\\t');\n  text = text.replace(/\\\\\\n/g, '\\n');\n  text = text.replace(/\\\\~/g, ' ');\n  text = text.replace(/\\\\_/g, '-');\n  text = text.replace(/\\\\\\{/g, '{');\n  text = text.replace(/\\\\\\}/g, '}');\n  text = text.replace(/\\\\\\\\/g, '\\\\');\n\n  // Remove all other control words\n  text = text.replace(/\\\\[a-z]+(-?\\d+)?\\s?/gi, '');\n\n  // Remove remaining braces\n  text = text.replace(/[{}]/g, '');\n\n  // Clean up whitespace\n  text = text.replace(/\\r\\n/g, '\\n');\n  text = text.replace(/\\r/g, '\\n');\n  text = text.replace(/\\n{3,}/g, '\\n\\n');\n  text = text.replace(/[ \\t]+/g, ' ');\n  text = text.replace(/^ +/gm, '');\n  text = text.trim();\n  return text;\n}\n\n// Process files from drag-drop or folder input\nexport function processFiles(files) {\n  const filesArray = Array.from(files);\n\n  // Filter for valid files\n  const validFiles = filesArray.filter(file => isValidFile(file.name));\n  if (validFiles.length === 0) {\n    return {\n      files: [],\n      error: 'No valid files found. Please upload images, videos, text, or markdown files.'\n    };\n  }\n\n  // Organize files by subdirectory\n  const filesByFolder = {};\n  const rootFiles = [];\n  const imagePathToBlobUrl = {};\n  const MAX_DEPTH = 2;\n  validFiles.forEach(file => {\n    const relativePath = file.webkitRelativePath || file.name;\n    const pathParts = relativePath.split('/');\n\n    // Store blob URLs for images (for markdown image references)\n    if (isImageFile(file.name)) {\n      const blobUrl = URL.createObjectURL(file);\n      const relativePathFromRoot = pathParts.length > 1 ? pathParts.slice(1).join('/') : file.name;\n      imagePathToBlobUrl[relativePathFromRoot] = blobUrl;\n      imagePathToBlobUrl['./' + relativePathFromRoot] = blobUrl;\n    }\n    if (pathParts.length <= 2) {\n      // Root file or file in root of selected folder\n      rootFiles.push(file);\n    } else {\n      const depth = pathParts.length - 2;\n      if (depth <= MAX_DEPTH) {\n        const subfolderPath = pathParts.slice(1, -1).join('/');\n        if (!filesByFolder[subfolderPath]) {\n          filesByFolder[subfolderPath] = [];\n        }\n        filesByFolder[subfolderPath].push(file);\n      }\n    }\n  });\n\n  // Build the gallery items array\n  const galleryItems = [];\n  let itemIndex = 0;\n\n  // Natural sort function\n  const naturalSort = (a, b) => {\n    const aName = a.name || a.webkitRelativePath.split('/').pop();\n    const bName = b.name || b.webkitRelativePath.split('/').pop();\n    return aName.localeCompare(bName, undefined, {\n      numeric: true,\n      sensitivity: 'base'\n    });\n  };\n\n  // Sort folder names\n  const folderNames = Object.keys(filesByFolder).sort((a, b) => a.localeCompare(b, undefined, {\n    numeric: true,\n    sensitivity: 'base'\n  }));\n\n  // Add root files first\n  if (rootFiles.length > 0) {\n    // Add divider for root files if there are also folders\n    if (folderNames.length > 0) {\n      galleryItems.push({\n        key: './',\n        type: 'divider',\n        url: null\n      });\n    }\n    rootFiles.sort(naturalSort);\n    rootFiles.forEach(file => {\n      const objectURL = URL.createObjectURL(file);\n      const displayName = getDisplayName(file.name);\n      const fileType = getFileType(file.name);\n      galleryItems.push({\n        key: `${++itemIndex}_${displayName}`,\n        url: objectURL,\n        type: fileType,\n        file: file,\n        originalName: file.name\n      });\n    });\n  }\n\n  // Add files by folder\n  folderNames.forEach(folderName => {\n    const folderFiles = filesByFolder[folderName];\n    folderFiles.sort(naturalSort);\n\n    // Add divider\n    galleryItems.push({\n      key: folderName,\n      type: 'divider',\n      url: null\n    });\n\n    // Add files\n    folderFiles.forEach(file => {\n      const objectURL = URL.createObjectURL(file);\n      const displayName = getDisplayName(file.name);\n      const fileType = getFileType(file.name);\n      galleryItems.push({\n        key: `${++itemIndex}_${displayName}`,\n        url: objectURL,\n        type: fileType,\n        file: file,\n        originalName: file.name\n      });\n    });\n  });\n  return {\n    files: galleryItems,\n    imagePathToBlobUrl,\n    error: null\n  };\n}","map":{"version":3,"names":["VIDEO_EXTENSIONS","IMAGE_EXTENSIONS","TEXT_EXTENSIONS","MARKDOWN_EXTENSIONS","isVideoFile","filename","lower","toLowerCase","some","ext","endsWith","isImageFile","isTextFile","isMarkdownFile","isRtfFile","isValidFile","getFileType","getFileExtension","match","getDisplayName","replace","rtfToPlainText","rtf","trim","startsWith","removeNestedGroups","text","groupName","pattern","RegExp","result","i","length","slice","indexOf","depth","groupsToRemove","group","hex","code","parseInt","win1252Map","String","fromCharCode","charCode","processFiles","files","filesArray","Array","from","validFiles","filter","file","name","error","filesByFolder","rootFiles","imagePathToBlobUrl","MAX_DEPTH","forEach","relativePath","webkitRelativePath","pathParts","split","blobUrl","URL","createObjectURL","relativePathFromRoot","join","push","subfolderPath","galleryItems","itemIndex","naturalSort","a","b","aName","pop","bName","localeCompare","undefined","numeric","sensitivity","folderNames","Object","keys","sort","key","type","url","objectURL","displayName","fileType","originalName","folderName","folderFiles"],"sources":["/Users/stanleytan/Documents/25-technical/01-github/vercel_textviewer/src/utils/fileUtils.js"],"sourcesContent":["// File type detection utilities\n\nconst VIDEO_EXTENSIONS = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.mkv', '.m4v'];\nconst IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg'];\nconst TEXT_EXTENSIONS = ['.txt', '.rtf'];\nconst MARKDOWN_EXTENSIONS = ['.md'];\n\nexport function isVideoFile(filename) {\n  const lower = filename.toLowerCase();\n  return VIDEO_EXTENSIONS.some(ext => lower.endsWith(ext));\n}\n\nexport function isImageFile(filename) {\n  const lower = filename.toLowerCase();\n  return IMAGE_EXTENSIONS.some(ext => lower.endsWith(ext));\n}\n\nexport function isTextFile(filename) {\n  const lower = filename.toLowerCase();\n  return TEXT_EXTENSIONS.some(ext => lower.endsWith(ext));\n}\n\nexport function isMarkdownFile(filename) {\n  const lower = filename.toLowerCase();\n  return MARKDOWN_EXTENSIONS.some(ext => lower.endsWith(ext));\n}\n\nexport function isRtfFile(filename) {\n  return filename.toLowerCase().endsWith('.rtf');\n}\n\nexport function isValidFile(filename) {\n  return isVideoFile(filename) || isImageFile(filename) || isTextFile(filename) || isMarkdownFile(filename);\n}\n\nexport function getFileType(filename) {\n  if (isMarkdownFile(filename)) return 'markdown';\n  if (isTextFile(filename)) return 'text';\n  if (isVideoFile(filename)) return 'video';\n  if (isImageFile(filename)) return 'image';\n  return 'unknown';\n}\n\nexport function getFileExtension(filename) {\n  const match = filename.match(/\\.[^.]+$/);\n  return match ? match[0].toLowerCase() : '';\n}\n\nexport function getDisplayName(filename) {\n  // Remove extension and return clean display name\n  return filename.replace(/\\.[^.]+$/, '');\n}\n\n// RTF to plain text converter (fallback for when rtf-parser fails)\nexport function rtfToPlainText(rtf) {\n  // Check if this is actually RTF content\n  if (!rtf.trim().startsWith('{\\\\rtf')) {\n    return rtf; // Not RTF, return as-is\n  }\n\n  // Remove nested groups (like fonttbl, colortbl, etc.) by counting braces\n  function removeNestedGroups(text, groupName) {\n    const pattern = new RegExp('\\\\{\\\\\\\\' + groupName, 'gi');\n    let result = '';\n    let i = 0;\n    while (i < text.length) {\n      const match = text.slice(i).match(pattern);\n      if (match && text.slice(i).indexOf(match[0]) === 0) {\n        // Found a group to remove, skip until balanced braces\n        let depth = 1;\n        i += match[0].length;\n        while (i < text.length && depth > 0) {\n          if (text[i] === '{') depth++;\n          else if (text[i] === '}') depth--;\n          i++;\n        }\n      } else {\n        result += text[i];\n        i++;\n      }\n    }\n    return result;\n  }\n\n  let text = rtf;\n\n  // Remove various RTF groups that don't contain readable text\n  const groupsToRemove = [\n    'fonttbl', 'colortbl', 'stylesheet', 'listtable', 'listoverridetable',\n    'info', 'expandedcolortbl', '\\\\*\\\\expandedcolortbl', '\\\\*\\\\listtable',\n    '\\\\*\\\\listoverridetable', 'listtext'\n  ];\n  for (const group of groupsToRemove) {\n    text = removeNestedGroups(text, group.replace(/\\\\/g, '\\\\\\\\'));\n  }\n\n  // Remove {\\*\\...} destination groups\n  text = text.replace(/\\{\\\\\\*\\\\[^{}]*\\}/g, '');\n\n  // Handle hex characters (\\'XX)\n  text = text.replace(/\\\\'([0-9a-fA-F]{2})/g, (match, hex) => {\n    const code = parseInt(hex, 16);\n    // Map Windows-1252 special chars to Unicode\n    const win1252Map = {\n      0x92: \"'\", 0x93: '\"', 0x94: '\"', 0x96: '–', 0x97: '—',\n      0x85: '…', 0x91: \"'\", 0xa0: ' '\n    };\n    return win1252Map[code] || String.fromCharCode(code);\n  });\n\n  // Handle Unicode characters (\\uN followed by replacement char)\n  text = text.replace(/\\\\u(-?\\d+)[\\s\\\\]?/g, (match, code) => {\n    const charCode = parseInt(code);\n    if (charCode < 0) return String.fromCharCode(charCode + 65536);\n    return String.fromCharCode(charCode);\n  });\n\n  // Replace RTF control words with their meaning\n  text = text.replace(/\\\\par\\b/g, '\\n');\n  text = text.replace(/\\\\line\\b/g, '\\n');\n  text = text.replace(/\\\\tab\\b/g, '\\t');\n  text = text.replace(/\\\\\\n/g, '\\n');\n  text = text.replace(/\\\\~/g, ' ');\n  text = text.replace(/\\\\_/g, '-');\n  text = text.replace(/\\\\\\{/g, '{');\n  text = text.replace(/\\\\\\}/g, '}');\n  text = text.replace(/\\\\\\\\/g, '\\\\');\n\n  // Remove all other control words\n  text = text.replace(/\\\\[a-z]+(-?\\d+)?\\s?/gi, '');\n\n  // Remove remaining braces\n  text = text.replace(/[{}]/g, '');\n\n  // Clean up whitespace\n  text = text.replace(/\\r\\n/g, '\\n');\n  text = text.replace(/\\r/g, '\\n');\n  text = text.replace(/\\n{3,}/g, '\\n\\n');\n  text = text.replace(/[ \\t]+/g, ' ');\n  text = text.replace(/^ +/gm, '');\n  text = text.trim();\n\n  return text;\n}\n\n// Process files from drag-drop or folder input\nexport function processFiles(files) {\n  const filesArray = Array.from(files);\n\n  // Filter for valid files\n  const validFiles = filesArray.filter(file => isValidFile(file.name));\n\n  if (validFiles.length === 0) {\n    return { files: [], error: 'No valid files found. Please upload images, videos, text, or markdown files.' };\n  }\n\n  // Organize files by subdirectory\n  const filesByFolder = {};\n  const rootFiles = [];\n  const imagePathToBlobUrl = {};\n  const MAX_DEPTH = 2;\n\n  validFiles.forEach(file => {\n    const relativePath = file.webkitRelativePath || file.name;\n    const pathParts = relativePath.split('/');\n\n    // Store blob URLs for images (for markdown image references)\n    if (isImageFile(file.name)) {\n      const blobUrl = URL.createObjectURL(file);\n      const relativePathFromRoot = pathParts.length > 1 ? pathParts.slice(1).join('/') : file.name;\n      imagePathToBlobUrl[relativePathFromRoot] = blobUrl;\n      imagePathToBlobUrl['./' + relativePathFromRoot] = blobUrl;\n    }\n\n    if (pathParts.length <= 2) {\n      // Root file or file in root of selected folder\n      rootFiles.push(file);\n    } else {\n      const depth = pathParts.length - 2;\n      if (depth <= MAX_DEPTH) {\n        const subfolderPath = pathParts.slice(1, -1).join('/');\n        if (!filesByFolder[subfolderPath]) {\n          filesByFolder[subfolderPath] = [];\n        }\n        filesByFolder[subfolderPath].push(file);\n      }\n    }\n  });\n\n  // Build the gallery items array\n  const galleryItems = [];\n  let itemIndex = 0;\n\n  // Natural sort function\n  const naturalSort = (a, b) => {\n    const aName = a.name || a.webkitRelativePath.split('/').pop();\n    const bName = b.name || b.webkitRelativePath.split('/').pop();\n    return aName.localeCompare(bName, undefined, { numeric: true, sensitivity: 'base' });\n  };\n\n  // Sort folder names\n  const folderNames = Object.keys(filesByFolder).sort((a, b) =>\n    a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })\n  );\n\n  // Add root files first\n  if (rootFiles.length > 0) {\n    // Add divider for root files if there are also folders\n    if (folderNames.length > 0) {\n      galleryItems.push({\n        key: './',\n        type: 'divider',\n        url: null\n      });\n    }\n\n    rootFiles.sort(naturalSort);\n\n    rootFiles.forEach(file => {\n      const objectURL = URL.createObjectURL(file);\n      const displayName = getDisplayName(file.name);\n      const fileType = getFileType(file.name);\n\n      galleryItems.push({\n        key: `${++itemIndex}_${displayName}`,\n        url: objectURL,\n        type: fileType,\n        file: file,\n        originalName: file.name\n      });\n    });\n  }\n\n  // Add files by folder\n  folderNames.forEach(folderName => {\n    const folderFiles = filesByFolder[folderName];\n    folderFiles.sort(naturalSort);\n\n    // Add divider\n    galleryItems.push({\n      key: folderName,\n      type: 'divider',\n      url: null\n    });\n\n    // Add files\n    folderFiles.forEach(file => {\n      const objectURL = URL.createObjectURL(file);\n      const displayName = getDisplayName(file.name);\n      const fileType = getFileType(file.name);\n\n      galleryItems.push({\n        key: `${++itemIndex}_${displayName}`,\n        url: objectURL,\n        type: fileType,\n        file: file,\n        originalName: file.name\n      });\n    });\n  });\n\n  return {\n    files: galleryItems,\n    imagePathToBlobUrl,\n    error: null\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}